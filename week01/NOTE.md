学习笔记

Week01

出题解题规律&思路：
1.嵌套循环遍历 + 左右边界向中间收敛 是常用方法。（盛水最多容器）
2.括号问题要想到“栈”
3.所有滑动窗口问题，都考虑用“队列（双端对列”）
4.Linked List类题目解法通常比较固定，注意熟能生巧（next,prev)
5.recursion类问题懵逼时：
  暴力解法/基本情况，同时，找“最近” “重复子问题”。


299.猜数字游戏笔记：
2020/10/24 C
解法一：
两次循环，同时开辟一个一维数组map[10]，数组下标表示数字0-9，数组元素表示下标对应数字出现次数（排除了全中数字后的次数）。
第一次遍历，遍历secret，与guess相比，全中的数字通过A++计数，同时在map中记录secret中没有被猜全中的数字（secret[i]-'0'）及个数。
第二次遍历，遍历guess，（guess[i]-'0'）在map[i]存在个数，同时secret[i]不等于guest[i]的，就用B++计数，然后再对map中记录的个数-1。
最后，A即公牛，同位且相等；B即母牛，值想等位置不对。

解法二：（骚操作，哈哈）
一次循环，依旧使用辅助以为数组map[10]，遍历时，遇见同位相等的直接A++。
同时，对于在secret中出现的数字（secret[i]-'0'）则在map中做自加操作；对于在guess中出现的数字（guess[i]-'0'）在map中做自减操作。
由此可得，在每次遇到secret[i]和guess[i]不同时，先看map对应的map[scret[i]-'0']是否小于0，如果小于0，则说明是被之前guess里没有匹配上位置的减过；同理，看map[guess[i]-'0']是否大于0，如果大于0，则说明被是被之前secret里没有匹配上位置的加过。对于这两种情况，说明secret和guess中同时存在，只是位置不同，所以B++。
注：可以用滞后自增简化代码。
另注：C语言的循环计数控制条件不是0-10，而是看每一个secret[i]元素是否存在。


